%alltop{/* gcompris - gc-sound-item.gob
 *
 * Copyright (C) 2006 Yves Combe
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
%}

requires 2.0.0

%h{
#ifndef __TYPEDEF_GC_SOUND_CHANNEL__
#define __TYPEDEF_GC_SOUND_CHANNEL__
typedef struct _GCSoundChannel GCSoundChannel;
#endif
%}

%{
#include <gc-sound-item.h>
#include <SDL.h>
#include <SDL_thread.h>
#include <SDL_mixer.h>
#include <SDL_audio.h>
#include <libintl.h>

#define _(String) gettext (String)
#define gettext_noop(String) String

#ifndef N_
#define N_(String) gettext_noop (String)
#endif

#include "gc-sound-item-private.h"

#include "gc-sound-channel.h"
%}

class GC:Sound:Item from G:Object {
  public gchar *nick = {NULL};

  private GC:Sound:Channel *channel = { NULL }
  destroywith g_object_unref ;  

  property OBJECT channel
     ( nick=_("Channel playing for us"),
        blurb=_("Numero of channel"),
        object_type=GC:Sound:Channel,
        export, link );

  private GC:Sound:Item *parent = { NULL }
  destroywith g_object_unref ;  

  property OBJECT parent
     ( nick=_("Channel playing for us"),
        blurb=_("Numero of channel"),
        object_type=GC:Sound:Item,
        export)
       set { self->_priv->parent = GC_SOUND_ITEM(g_value_get_object 
(VAL));
       }
       get { g_value_set_object (VAL, G_OBJECT(self->_priv->parent)); }
    ;

  private gchar *filename = { NULL }
  destroywith g_free;

  public int volume = { -1 };

  /* mark if item or one child is playing */
  private gboolean started = { FALSE };

  /* mark if is playing or not */
  private gboolean has_played = { FALSE };

  property STRING filename
     ( nick=_("Filename of sound"),
        blurb=_("sound file to play"),
        export )
      set {
        if (self->_priv->filename==NULL)
           g_free(self->_priv->filename);

	self->_priv->filename = g_strdup(g_value_get_string(VAL));
        self->_priv->PlayList = g_list_remove ( self->_priv->PlayList, self);

        if (self->_priv->filename)
           self->_priv->PlayList = g_list_insert ( self->_priv->PlayList, self, 0);

	}
      get {  g_value_set_string(VAL, g_strdup(self->_priv->filename));};


  private G:List *playing = { NULL };

  private G:List *SoundItems = { NULL }
  destroy {
    GList *list;

    for (list = SoundItems; list != NULL; list = list->next)
         g_object_unref(G_OBJECT(list->data));

    g_list_free (SoundItems);
  };

  private GList *PlayList = { NULL }
  destroy {
    g_list_free (PlayList);
  };

  init (self)  {
    g_warning("Item sound instance init");
  }

  class_init (class) {
     g_warning("item sound class init");

  }

  public GC:Sound:Item *
    new (self)
    {
      GCSoundItem *child;

      child = GC_SOUND_ITEM(g_object_new(gc_sound_item_get_type(), "parent", self, "channel", self->_priv->channel, NULL));

      self->_priv->SoundItems = g_list_append (self->_priv->SoundItems, child);
      self->_priv->PlayList = g_list_append (self->_priv->PlayList, child);

      g_object_ref (G_OBJECT(child));

      self_connect__play_finished ( child, self_child_play_finished, self);
      self_connect__play_started ( child, self_child_play_started, self);
      
      return child;
    }

  public void
    play (self)
     {
        /* Change that with policy */
        self->_priv->has_played = TRUE;
	gc_sound_channel_play_item(self->_priv->channel, self);
     }


   protected void
     play_next (self) 
      {
        self->_priv->has_played = TRUE;
  
        if (g_list_length(self->_priv->PlayList) > 0) {
            if (self->_priv->playing == NULL)  {
               self->_priv->playing = g_list_first(self->_priv->PlayList);
            } else
              self->_priv->playing = g_list_next (self->_priv->playing );

            if ( self->_priv->playing == NULL )
                 self_play_finished(self); 
            else {
             if ( GC_SOUND_ITEM(self->_priv->playing->data) == self){
                self_play_started(self);
                gc_sound_channel_real_play(self->_priv->channel, self);
                }
             else
                gc_sound_item_play_next ( GC_SOUND_ITEM(self->_priv->playing->data));
            }
         }
        
     }

  /* play */
  signal last NONE (NONE)
     void play_finished (self)
  {
    //g_warning("play_finished %s", self->nick);

    if (self->_priv->has_played && self->_priv->playing) {
       self_play_next(self);
       }
    else {
       self->_priv->started = FALSE;
       self->_priv->has_played = FALSE;
       }
  }
  signal last NONE (NONE)
     void play_started (self)
  {
    //g_warning("play_started %s", self->nick);
    self->_priv->started = TRUE;
  }

  private void child_play_finished (GC:Sound:Item *item, gpointer data)
   {
       if ( GC_SOUND_ITEM(data)->_priv->has_played )
          self_play_next(GC_SOUND_ITEM(data));
   }  

  private void child_play_started (GC:Sound:Item *item, gpointer data)
   {
       if (! GC_SOUND_ITEM(data)->_priv->started)
          self_play_started(GC_SOUND_ITEM(data));
   }  
}
