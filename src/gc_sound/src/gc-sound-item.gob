%alltop{/* gcompris - gc-sound-item.gob
 *
 * Copyright (C) 2006 Yves Combe
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
%}

requires 2.0.0

%h{
#ifndef __TYPEDEF_GC_SOUND_CHANNEL__
#define __TYPEDEF_GC_SOUND_CHANNEL__
typedef struct _GCSoundChannel GCSoundChannel;
#endif
%}

%{
#include <gc-sound-item.h>
#include <SDL.h>
#include <SDL_thread.h>
#include <SDL_mixer.h>
#include <SDL_audio.h>
#include <libintl.h>

#define _(String) gettext (String)
#define gettext_noop(String) String

#ifndef N_
#define N_(String) gettext_noop (String)
#endif

#include "gc-sound-item-private.h"

#include "gc-sound-channel.h"
%}

class GC:Sound:Item from G:Object {
  /* debug */
  public gchar *nick = {NULL};

  /*************************/
  /* muted or not ?        */
  public gboolean mute = { FALSE };

  property BOOLEAN mute
     ( nick=_("Mute"),
        blurb=_("Do not play me"),
        export, link );

  /*************************/
  /* loop or not ?        */
  public gboolean loop = { FALSE };

  property BOOLEAN loop
     ( nick=_("Loop"),
        blurb=_("Play loop"),
        export, link );

  /*************************/
  /* channel where we play */
  private GC:Sound:Channel *channel = { NULL }
  destroywith g_object_unref ;  

  property OBJECT channel
     ( nick=_("Channel playing for us"),
        blurb=_("Numero of channel"),
        object_type=GC:Sound:Channel,
        export )
       set { self->_priv->channel = GC_SOUND_CHANNEL(g_value_get_object 
(VAL));
       gc_sound_channel_connect_me( self->_priv->channel, self);
       }
       get { g_value_set_object (VAL, G_OBJECT(self->_priv->channel)); };

  /*******************************************************/
  /* Parent is another item. We receive channel from it. */
  private GC:Sound:Item *parent = { NULL }
  destroywith g_object_unref ;  

  property OBJECT parent
     ( nick=_("Channel playing for us"),
        blurb=_("Numero of channel"),
        object_type=GC:Sound:Item,
        export)
       set { self->_priv->parent = GC_SOUND_ITEM(g_value_get_object 
(VAL));
       }
       get { g_value_set_object (VAL, G_OBJECT(self->_priv->parent)); }
    ;

  /********************************************/
  /* filename is the name of file we play     */
  /* may be NULL, in case we are only a group */
  private gchar *filename = { NULL }
  destroywith g_free;
  property STRING filename
     ( nick=_("Filename of sound"),
        blurb=_("sound file to play"),
        export )
      set {
        if (self->_priv->filename==NULL)
           g_free(self->_priv->filename);

	self->_priv->filename = g_strdup(g_value_get_string(VAL));
        self->_priv->PlayList = g_list_remove ( self->_priv->PlayList, self);

        if (self->_priv->filename)
           self->_priv->PlayList = g_list_insert ( self->_priv->PlayList, self, 0);

	}
      get {  g_value_set_string(VAL, g_strdup(self->_priv->filename));};

  /*******************************************/
  /* Volume for the sound                    */
  public int volume = { -1 };

  /****************************************/
  /* mark if item or one child is playing */
  private gboolean started = { FALSE };

  /*****************************/
  /* mark if is playing or not */
  private gboolean has_played = { FALSE };

  /* playing part of the child */
  private G:List *playing = { NULL };

  /* childs */
  private G:List *SoundItems = { NULL }
  destroy {
    GList *list;

    for (list = SoundItems; list != NULL; list = list->next)
         g_object_unref(G_OBJECT(list->data));

    g_list_free (SoundItems);
  };


  /* PlayList */
  private GList *PlayList = { NULL }
  destroy {
    g_list_free (PlayList);
  };


  /* Objects methods */
  init (self)  {
    g_warning("Item sound instance init");
    /* do nothing. We set up channel when property is set */
  }

  class_init (class) {
     g_warning("item sound class init");

  }

  public GC:Sound:Item *
    new (self)
    {
      GCSoundItem *child;

      child = GC_SOUND_ITEM(g_object_new(gc_sound_item_get_type(), "parent", self, "channel", self->_priv->channel, NULL));

      /* Child is added to our lists */
      self->_priv->SoundItems = g_list_append (self->_priv->SoundItems, child);
      self->_priv->PlayList = g_list_append (self->_priv->PlayList, child);

      /* we get a ref */
      g_object_ref (G_OBJECT(child));

      /* we need to know if start play or end on it, to send the same signal (group start/end) */
      self_connect__play_finished ( child, self_child_play_finished, self);
      self_connect__play_started ( child, self_child_play_started, self);
      
      return child;
    }

  public void
    play (self)
     {
        /* Change that with policy */
        self->_priv->has_played = TRUE;

        /* we will be added in play list channel */
	gc_sound_channel_play_item(self->_priv->channel, self);
     }


   /* recursive play in group */
   protected gboolean
     play_next (self) 
      {
        gboolean ret;
        if (self->mute)
           return FALSE;
        /* mark if we are in play tree */
        self->_priv->has_played = TRUE;

        if (g_list_length(self->_priv->PlayList) == 0)
           return FALSE;

        if (self->_priv->playing == NULL)
            self->_priv->playing = g_list_first(self->_priv->PlayList);
        else
            self->_priv->playing = g_list_next (self->_priv->playing );

        if ((self->_priv->playing == NULL) && (self->loop)) {
            g_warning ("looping on %s", self->nick);
            self->_priv->playing = g_list_first (self->_priv->PlayList );         
            }
  
        while (self->_priv->playing) {
             if ( GC_SOUND_ITEM(self->_priv->playing->data) == self){
                if (!self->_priv->started)
                   self_play_started(self);
                gc_sound_channel_real_play(self->_priv->channel, self);
                return TRUE;
                }
             else {
                ret= gc_sound_item_play_next ( GC_SOUND_ITEM(self->_priv->playing->data));
                if (ret)
                   return ret;
                } 
             self->_priv->playing = g_list_next (self->_priv->playing );
             }    

        /* if we have play, it's finished */
        if (self->_priv->started) {
            g_warning("Call play_finished %s %d %d", self->nick, self->_priv->has_played, self->_priv->playing);

            self_play_finished(self);
        }           

        return FALSE;
     }

  /* play */
  signal first NONE (NONE)
     void play_finished (self)
  {
    g_warning("play_finished %s %d %d", self->nick, self->_priv->has_played, self->_priv->playing);

    if ((!self->_priv->has_played) || (!self->_priv->playing)) {
       self->_priv->started = FALSE;
       self->_priv->has_played = FALSE;
       }
  }

  signal last NONE (NONE)
     void play_started (self)
  {
    //g_warning("play_started %s", self->nick);
    self->_priv->started = TRUE;
  }

  private void child_play_finished (GC:Sound:Item *item, gpointer data)
   {
       if ( GC_SOUND_ITEM(data)->_priv->has_played )
          self_play_next(GC_SOUND_ITEM(data));
   }  

  private void child_play_started (GC:Sound:Item *item, gpointer data)
   {
       if (! GC_SOUND_ITEM(data)->_priv->started)
          self_play_started(GC_SOUND_ITEM(data));
   }  
}
