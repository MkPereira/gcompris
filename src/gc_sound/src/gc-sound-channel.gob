%alltop{/* gcompris - gc-sound-channel.gob
 *
 * Copyright (C) 2006 Yves Combe
 *
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
%}

requires 2.0.0

%{
#include <gc-sound-channel.h>
#include <SDL.h>
#include <SDL_thread.h>
#include <SDL_mixer.h>
#include <SDL_audio.h>
#include <libintl.h>

#define _(String) gettext (String)
#define gettext_noop(String) String

#ifndef N_
#define N_(String) gettext_noop (String)
#endif

#include "gc-sound-channel-private.h"
#include "gc-sound-item-private.h"
%}

%h{
#include <gc-sound.h>
%}


%{
static GHashTable *channels_table = NULL;
%}

enum GC_SOUND {
     POLICY_NONE,
     PLAY_ONLY_IF_IDLE,
     PLAY_AFTER_CURRENT,
     INTERRUPT_AND_PLAY
} GC:Sound:Policy;

class GC:Sound:Channel from G:Object {
  public gchar *nick = {NULL};

  /* channel is the mixer channel number we use */
  private int channel
  destroy {
    g_hash_table_remove(channels_table, GINT_TO_POINTER(channel));

    if (g_hash_table_size (channels_table) == 0) {
      g_hash_table_destroy(channels_table);
      channels_table = NULL;
    }
  };

  private gboolean initialised = {FALSE};

  private Mix_Chunk *sample;
  private GC:Sound:Item *playing_item = { NULL };
  private G:List *playing_root = { NULL }; 
  private G:List *play_list = { NULL };

  /* the default volume for the channel */
  private int volume = { MIX_MAX_VOLUME };
  property INT volume
     ( nick= _("Channel volume"),
       blurb= _("Default volume of the channel"),
       export,
       link);

  /* The default policy for the channel */
  private GCSoundPolicy policy = {GC_SOUND_PLAY_AFTER_CURRENT};
  property ENUM policy
      ( nick = _("Channel policy"),
        blurb = _("Default policy for this channel"),
        enum_type = GC:Sound:Policy,
        export, link);

  /* the mixer we are attached on */
  /* The mixer initalise SDL and audio */
  private GC:Sound:Mixer *mixer = { NULL }
  destroywith g_object_unref ;  

  property OBJECT mixer
     (nick = _("GCompris Sound Mixer"),
      blurb = _("GCompris Sound Mixer where this sound channel is"),
      object_type=GC:Sound:Mixer,
      flags = CONSTRUCT_ONLY,
      export)
      set { self->_priv->mixer = GC_SOUND_MIXER(g_value_get_object 
(VAL)); 
              self->_priv->channel = self->_priv->mixer->channels++ ;
              Mix_AllocateChannels(self->_priv->mixer->channels );

               g_warning("Channel #%d initialised", self->_priv->channel);
		 Mix_HaltChannel(self->_priv->channel);

               g_hash_table_insert(channels_table, &(self->_priv->channel), self);

               self->_priv->rootItem = GC_SOUND_ITEM(g_object_new(gc_sound_item_get_type(), "channel", self, NULL));

               g_object_ref(self->_priv->rootItem);
               
      }
      get { g_value_set_object (VAL, G_OBJECT(self->_priv->channel)); }
       ;

  private GC:Sound:Item *rootItem = { NULL }
  destroywith g_object_unref;

  property OBJECT rootItem
     (nick = _("GCompris Sound Item root"),
      blurb = _("GCompris Sound Item root"),
      object_type=GC:Sound:Item,
      export, link)
       ;

  private gboolean stopped = { FALSE };

  init (self)  {
    //g_warning("gc channel instance init"); 
    if (!channels_table)
      channels_table = g_hash_table_new (g_int_hash, g_int_equal);

    Mix_ChannelFinished(self_channel_finished);
  }

  class_init (class) {
    //g_warning("gc channel class init"); 
  }

  public GC:Sound:Item *
    new_item (self)
    {
      return GC_SOUND_ITEM(g_object_new(gc_sound_item_get_type(), "parent", self->_priv->rootItem, NULL));
    }

  private void channel_finished (int channel)
    {
      /* check we are on the right channel */
      /* this a too simple callback */
      /* get self */
      GCSoundChannel *self;

      //g_warning ("Channel finished %d", channel);

      self = GC_SOUND_CHANNEL(g_hash_table_lookup(channels_table, &channel));

      if (!self) {
           g_warning ("Cannot get GCSoundChannel from hash !!!!!");
           return;
      }
      self_play_finished (self, self->_priv->playing_item);
    }

   private void real_play ( GC:Sound:Item *item, gpointer data)
    {
      //g_warning ("Real play %s", item->nick);
      GCSoundChannel *self = GC_SOUND_CHANNEL(data);

      gchar * filename = gc_sound_item_get_filename(item);

      if (Mix_Playing(self->_priv->channel)){
         g_warning("Channel busy ? no play!");
         return;
         }

      if (filename == NULL){
         g_warning("No filename ? no play!");
         return;
         }

      self->_priv->sample=Mix_LoadWAV_RW(SDL_RWFromFile(filename, "rb"), 1);
     if (!self->_priv->sample) {
        g_warning("Sample music %s cannot be load", filename); 
        return;
        }

     if ((item->volume == -1) || (item->volume >  self->_priv->volume))
        Mix_VolumeChunk(self->_priv->sample, self->_priv->volume);
     else
        Mix_VolumeChunk(self->_priv->sample, item->volume);

     if (Mix_PlayChannel(self->_priv->channel, self->_priv->sample, 0)==-1) {
        g_warning("Channel cannot play music %s", filename);
        return;
        }

     g_warning("Playing %s on channel #%d", filename, self->_priv->channel);


     self->_priv->playing_item = item;
   }


  signal first NONE (POINTER)
     void play_finished (self, GC:Sound:Item *item (check null type))
  {
        //g_warning ("Channel finish item %s", item->nick);
        Mix_FreeChunk(self->_priv->sample);
        self->_priv->sample = NULL;

        gc_sound_item_play_next(item, self->_priv->stopped);
  }

  /* connected to do_play signal of item */
  protected void do_play (GC:Sound:Item *item, gpointer data)
    {
      GCSoundChannel *self = GC_SOUND_CHANNEL(data);
      GCSoundPolicy policy;

      /* item policy if it's set */
      if (gc_sound_item_get_policy(item) == GC_SOUND_POLICY_NONE)
         policy = self->_priv->policy;
      else
         policy = gc_sound_item_get_policy(item);

     //g_warning ("play_item %s with policy %d", item->nick, policy);

      switch (policy) {
        case GC_SOUND_PLAY_ONLY_IF_IDLE:
             if (self->_priv->sample || g_list_length (self->_priv->play_list)>0)
                return;
             break;

        case GC_SOUND_INTERRUPT_AND_PLAY:
	  g_list_free (self->_priv->play_list);
          self->_priv->play_list = NULL;
          self->_priv->play_list = g_list_append (self->_priv->play_list, item);
          if (self->_priv->sample){
             self->_priv->stopped = TRUE;
             //g_warning("halting channel %d %d", self->_priv->channel, g_list_length(self->_priv->play_list));
             self_halt(self);
          }
          self_run(self);
          break;

        default:
                 self->_priv->play_list = g_list_append (self->_priv->play_list, item);
                 if (!self->_priv->sample)
                    self_run(self);
                 break;
      }
    }

  protected void play_first_item(self)
    {
      gboolean ret;

      while (g_list_length(self->_priv->play_list)>0)
        {
           self->_priv->playing_root = g_list_first (self->_priv->play_list);
           self->_priv->play_list = g_list_remove_link  (self->_priv->play_list, self->_priv->playing_root);

          ret = gc_sound_item_play_next (GC_SOUND_ITEM(self->_priv->playing_root->data), FALSE);
          if (ret)
             return ;          
        }
    }

  private void item_play_finished (GC:Sound:Item *item, gboolean stopped, gpointer data)
    {
        //g_warning("channel item_play_finished %s %s", item->nick, stopped ? "STOPPED":"normal");

        /* if item our our root item playing */
        if (item == GC_SOUND_ITEM(GC_SOUND_CHANNEL(data)->_priv->playing_root->data))
           {
             GC_SOUND_CHANNEL(data)->_priv->playing_root = NULL;
             /* do not call run if we are stopping */
             if (GC_SOUND_CHANNEL(data)->_priv->stopped)
                GC_SOUND_CHANNEL(data)->_priv->stopped = FALSE;
             else
                self_run(GC_SOUND_CHANNEL(data));
           }
    }

  public void connect_me (self, GC:Sound:Item *item )
    {
      gc_sound_item_connect__play_finished(item, self_item_play_finished, self);
      gc_sound_item_connect__do_play(item, self_do_play, self);
      gc_sound_item_connect__real_play(item, self_real_play, self);

    }

  private signal first NONE (NONE)
    void run (self)
      {
         //g_warning("channel run");
         self_play_first_item(self);
      }

  public signal first NONE (NONE)
    void halt (self)
      {
         //g_warning("halting channel %d", self->_priv->channel);
         Mix_HaltChannel(self->_priv->channel);
      }

  private signal first NONE (POINTER)
     void halt_and_play (self, GC:Sound:Item *item )
      {
      }

}
