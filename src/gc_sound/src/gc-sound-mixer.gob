%alltop{/* gcompris - gc-sound-mixer.gob
 *
 * Copyright (C) 2006 Yves Combe
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
%}

requires 2.0.0

%{
#include "gc-sound-mixer.h"
#include "gc-sound-channel.h"
#include "SDL.h"
#include "SDL_thread.h"
#include "SDL_mixer.h"
#include "SDL_audio.h"
#include "libintl.h"

#define _(String) gettext (String)
#define gettext_noop(String) String

#ifndef N_
#define N_(String) gettext_noop (String)
#endif

#include "gc-sound-mixer-private.h"
%}

%h{
#ifndef __TYPEDEF_GC_SOUND_CHANNEL__
#define __TYPEDEF_GC_SOUND_CHANNEL__
typedef struct _GCSoundChannel GCSoundChannel;
#endif
%}
class GC:Sound:Mixer from G:Object {
  protected int channels = { 0 };

  private int audio_buffers=2048;
  private int bits = 0;

  private G:List *channels_list = { NULL }
  destroy {
    GList *chan;
     for (chan = channels_list; chan != NULL; chan = g_list_next (chan)) {
        g_object_unref (chan);
        }

     g_list_free (channels_list);
  };

  private gboolean audio_device = { FALSE}
  destroy {
    self_set_audio_device(self, FALSE);
     if (self->_priv->sdl_ok)
         SDL_Quit();
  };

  property BOOLEAN audio_device 
     (    nick = _("Audio device opened"),
          blurb = _("Open and close the audio device"),
          export )
         set {
           int audio_rate,audio_channels;
           Uint16 audio_format;

           gboolean val = g_value_get_boolean (VAL);
            if ( val != self->_priv->audio_device) {
                 if (val) {
                   // initialize sdl mixer, open up the audio device
                   if(Mix_OpenAudio(44100,MIX_DEFAULT_FORMAT,2,self->_priv->audio_buffers)<0){
                       g_warning("GCSoundMixer can not open audio dev");
                       return;
                        }

                   // print out some info on the audio device and stream
                  Mix_QuerySpec(&audio_rate, &audio_format, &audio_channels);
                  self->_priv->bits=audio_format&0xFF;
                   Mix_AllocateChannels(self->channels );
                  g_warning("Opened audio at %d Hz %d bit %s, %d bytes audio buffer\n Numbers of channels %d", audio_rate,
	    self->_priv->bits, audio_channels>1?"stereo":"mono", self->_priv->audio_buffers, self->channels);

                   Mix_AllocateChannels(self->channels );
                   } else {
                     Mix_CloseAudio();
                     g_warning("Closing audio"); 
                   }

                   self->_priv->audio_device = val;
             }
       }
        get { g_value_set_boolean (VAL, self->_priv->audio_device); };


  private gboolean sdl_ok = { FALSE };

  init (self)  {
    g_warning("gc mixer init");
    
    // initialize SDL for audio
    if(SDL_Init(SDL_INIT_AUDIO)<0){
      g_warning("SDL_init failed");
       self->_priv->sdl_ok = FALSE;
    } else
      self->_priv->sdl_ok = TRUE;

    self_set_audio_device(self, TRUE);
}

  class_init (class) {
     g_warning("gc mixer class init");

  }

  public G:Object *
    new (void)
    {
      return (GObject *)GET_NEW;
    }

   public void close_audio(self)
   {
      self_set_audio_device( self, FALSE);
   }
   public void open_audio(self)
   {
      self_set_audio_device( self, TRUE);
   }

   public GC:Sound:Channel *
   new_channel(self)
   {
       GCSoundChannel *new_channel;

       new_channel = GC_SOUND_CHANNEL(g_object_new(gc_sound_channel_get_type(), "mixer", self, NULL));
       g_object_ref (new_channel);

       self->_priv->channels_list = g_list_append(self->_priv->channels_list, new_channel);

       return new_channel;
   }

}
